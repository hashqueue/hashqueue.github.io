---
title: Java语言概述与开发环境配置
date: 2021-08-09 23:12:01
permalink: /pages/02590c/
categories:
  - 后端
  - Java
tags:
  - 
---
# Java语言概述与开发环境

[toc]

## Java语言发展简史

### 概述

Java语言是一门非常纯粹的面向对象编程语言,它吸收了C++语言的各种优点,又摒弃了C++里难以理解的多继承、指针等概念,因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表,极好地实现了面向对象理论,允许程序员以优雅的思维方式进行复杂的编程开发。

### Java语言发展历程
![Java语言发展历程-13726692df4d484f856c8fb9d2c6b01f](https://www.wenbin.org.cn/upload/2020/04/Java%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B-13726692df4d484f856c8fb9d2c6b01f-239f022a18e544dda2deb28188c182fe.jpg)

## 编译型语言和解释型语言

Java语言是一种特殊的高级语言,它既具有解释型语言的特征,也具有编译型语言的特征,因为Java程序要经过先编译,后解释两个步骤。

计算机高级语言按程序的执行方式可以分为编译型和解释型两种。

* 编译型语言是指使用专门的编译器,针对特定平台(操作系统)将某种高级语言源代码一次性"翻译"成可被该平台硬件执行的机器码(包括机器指令和操作数),并包装成该平台所能识别的可执行性程序的格式,这个转换过程称为编译(Compile)。编译生成的可执行性程序可以脱离开发环境,在特定的平台上独立运行。
    * 有些程序编译结束后,还可能需要对其他编译好的目标代码进行链接,即组装两个以上的目标代码模块生成最终的可执行性程序,通过这种方式实现低层次的代码复用。
    * 因为编译型语言是一次性地编译成机器码,所以可以脱离开发环境独立运行,而且通常运行效率较高;但因为编译型语言的程序被编译成特定平台上的机器码,因此编译生成的可执行性程序通常无法移植到其他平台上运行;如果需要移植,则必须将源代码复制到特定平台上,针对特定平台进行修改,至少也需要采用特定平台上的编译器重新编译。
    * 现有的C、C++、Objective-C、Swift、Kotlin等高级语言都属于编译型语言。
* 解释型语言是指使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行的语言。
    * 解释型语言通常不会进行整体性的编译和链接处理,解释型语言相当于把编译型语言中的编译和解释过程混合到一起同时完成。
    * 可以认为:每次执行解释型语言的程序都需要进行一次编译,因此解释型语言的程序运行效率通常较低,而且不能脱离解释器独立运行。但解释型语言有一个优势:跨平台比较容易,只需提供特定平台的解释器即可,每个特定平台上的解释器负责将源程序解释成特定平台的机器指令即可。解释型语言可以方便地实现源程序级的移植,但这是以牺牲程序执行效率为代价的。
    * 现有的JavaScript、Ruby、Python等语言都属于解释型语言。

## Java语言的编译,解释运行机制

Java语言比较特殊,由Java语言编写的程序需要经过编译步骤,但这个编译步骤并不会生成特定平台的机器码,而是生成一种与平台无关的字节码(也就是*.class文件)。当然,这种字节码不是可执行的,必须使用Java解释器来解释执行。因此可以认为:Java语言既是编译型语言,也是解释型语言。或者说,Java语言既不是纯粹的编译型语言,也不是纯粹的解释型语言。Java程序的执行过程必须经过先编译、后解释两个步骤,如下图所示。

![image-20200321125950015-acbc088974fb40bc97fc3962d893da46](https://www.wenbin.org.cn/upload/2020/04/image-20200321125950015-acbc088974fb40bc97fc3962d893da46-b37e31204c0249bb9d3ee367d54864c7.png)

## 通过JVM实现跨平台

* Java语言里负责解释执行字节码文件的是Java虚拟机,即JVM(JavaVirtualMachine) JVM是可运行Java字节码文件的虚拟计算机。所有平台上的JVM向编译器提供相同的编程接口,而编译器只需要面向虚拟机,生成虚拟机能理解的代码,然后由虚拟机来解释执行。在一些虚拟机的实现中,还会将虚拟机代码转换成特定系统的机器码执行,从而提高执行效率。
* 当使用Java编译器编译Java程序时,生成的是与平台无关的字节码,这些字节码不面向任何具体平台,只面向JVM。不同平台上的JVM都是不同的,但它们都提供了相同的接口。JVM是Java程序跨平台的关键部分,只要为不同平台实现了相应的虚拟机,编译后的Java字节码就可以在该平台上运行。显然,相同的宇节码程序需要在不同的平台上运行,这几乎是"不可能的",只有通过中间的转换器才可以实现,JVM就是这个转换器。
* JVM是一个抽象的计算机,和实际的计算机一样,它具有指令集并使用不同的存储区域。它负责执行指令,还要管理数据、内存和寄存器。

JVM的作用很容易理解,就像有两支不同的笔,但需要把同一个笔帽套在两支不同的笔上,只有为这两支笔分别提供一个转换器,这个转换器向上的接口相同,用于适应同一个笔帽;向下的接口不同,用于适应两支不同的笔。在这个类比中,可以近似地理解两支不同的笔就是不同的操作系统,而同一个笔帽就是Java字节码程序,转换器角色则对应JVM。类似地,也可以认为JVM分为向上和向下两个部分,所有平台上的JVM向上提供给Java字节码程序的接口完全相同,但向下适应不同平台的接口则互不相同。

Oracle公司制定的Java虚拟机规范在技术上规定了JVM的统一标准,具体定义了JVM的如下细节:
* 指令集
* 寄存器
* 类文件的格式
* 栈
* 垃圾回收堆
* 存储区

Oracle公司制定这些规范的目的是为了提供统一的标准,最终实现Java程序的平台无关性。

## 安装JDK
在开发Java程序之前,必须先完成一些准备工作,也就是在计算机上安装并配置Java开发环境,开发Java程序需要安装和配置JDK。

Java JDK在linux系统有两个版本，一个开源版本OpenJDK，还有一个oracle官方版本JDK。目前企业里没有特殊需求的话都是使用的Java8版本的OpenJDK。

### Ubuntu18.04安装Java8的JDK

卸载Ubuntu自带的OpenJDK 11
```bash
sudo apt-get remove openjdk*
```
更新软件包列表
```bash
sudo apt-get update
```
安装openjdk-8-jdk
```bash
sudo apt-get install openjdk-8-jdk
```
查看java版本，验证是否安装成功
```bash
java -version
```
终端输出
```bash
openjdk version "1.8.0_242"
OpenJDK Runtime Environment (build 1.8.0_242-8u242-b08-0ubuntu3~18.04-b08)
OpenJDK 64-Bit Server VM (build 25.242-b08, mixed mode)
```
查看javac版本，验证是否安装成功
```bash
javac -version
```
终端输出
```bash
javac 1.8.0_242
```
一般而言,如果只是运行Java程序,可以只安装JRE,无须安装JDK。

注意:
* 如果需要开发Java程序,则应该选择安装JDK;当然,安装了JDK之后,就包含了JRE,也可以运行Java程序。但如果只是运行Java程序,则需要在计算机上安装JRE,仅安装JVM是不够的。实际上,Oracle网站上提供的就是JRE的下载,并不提供单独JVM的下载。
* Oracle把Java分为JavaSE、JavaEE和JavaME三个部分,而且为JavaSE和JavaEE分别提供了JDK和JavaEESDK(SoftwareDevelopmentKit)两个开发包,如果读者只需要学习JavaSE的编程知识,则可以下载标准的JDK;如果读者学完JavaSE之后,还需要继续学习JavaEE相关内容,也可以选择下载JavaEESDK,有一个JavaEESDK版本里己经包含了最新版的JDK,安装JavaEESDK就包含了JDK。
* JavaSE,JavaEE,JavaME三者的区别：
    * JavaSE:即J2SE,java标准版,主要做一般的java应用,比如,应用软件/QQ之类的通信软件等等.
    * JavaEE:即J2EE,主要做企业应用,比如公司网站,企业解决方案等;
    * JavaME:即J2ME,主要面向嵌入式等设备应用的开发,比如手机游戏等.
## 编写,运行Java程序
编写Hello World
```java
public class HelloWorld {
    //main方法，程序的入口
    public static void main(String[] args) {
        //打印Hello World!并换行
        System.out.println("Hello World!");
        //打印Hello World!不换行
        System.out.print("Hello World!");
        System.out.print("Hello World!");
    }
}
```
编辑上面的Java文件时,注意程序中粗体宇标识的单词,Java程序严格区分大小写。
## Java程序的组织形式
* Java程序是一种纯粹的面向对象的程序设计语言,因此Java程序必须以类(class)的形式存在,类(class)是Java程序的最小程序单位。Java程序不允许可执行性语句、方法等成分独立存在,所有的程序部分都必须放在类定义里。
* Java解释器规定:如需某个类能被解释器直接解释执行,则这个类里必须包含`main`方法,而且`main`方法必须使用`public static void`来修饰,且`main`方法的形参必须是字符串数组类型(`String[] args`是字符串数组的形式)。也就是说,`main`方法的写法几乎是固定的。Java虚拟机就从这个`main`方法开始解释执行,因此,`main`方法是Java程序的入口。
* 对于那些不包含`main`方法的类,也是有用的类。对于一个大型的Java程序而言,往往只需要一个入口,也就是只有一个类包含`main`方法,而其他类都是用于被`main`方法直接或间接调用的。
## Java源文件的命名规则
Java程序源文件的命名不是随意的,Java文件的命名必须满足如下规则。
* Java程序源文件的扩展名必须是`.java`,不能是其他文件扩展名。
* 在通常情况下,Java程序源文件的主文件名可以是任意的。但有一种情况例外:如果Java程序源代码里定义了一个`public`类,则该源文件的主文件名必须与该`public`类(也就是该类定义使用了`public`关键宇修饰〉的类名相同。
* 由于Java程序源文件的文件名必须与`public`类的类名相同,因此,一个Java源文件里最多只能定义一个public类。
* 一个Java源文件可以包含多个类定义,但最多只能包含一个`public`类定义;如果Java源文件里包含`public`类定义,则该源文件的文件名必须与这个`public`类的类名相同。
* 虽然Java源文件里没有包含`public`类定义时,这个源文件的文件名可以是随意的,但推荐让Java源文件的主文件名与类名相同,这可以提供更好的可读性。通常有如下建议:
    * 一个Java源文件只定义一个类,不同的类使用不同的源文件定义。
    * 让Java源文件的主文件名与该源文件中定义的`public`类同名。
## 初学者易犯的错误
### CLASSPATH 环境变量的问题
* 如果使用1.5以上版本的JDK,完全可以不用设置这个环境变量。如果不设置这个环境变量,将可以正常编译和运行Java程序。
### 大小写问题
* Java语言是严格区分大小写的语言。(Linux平台是区分大小写的)。
* 例如`class`和`Class`是不同的两个词,`class`是正确的,但如果写成`Class`,则程序无法编译通过。实际上,Java程序中的关键宇全部是小写的,无须大写任何字母。
### `main`方法的问题
* 如果需要用Java命令直接运行一个Java类,这个Java类必须包含`main`方法
* 这个`main`方法必须使用`public`和`static`来修饰,必须使用`void`声明该方法的返回值
* 且该方法的参数类型只能是一个字符串数组,而不能是其他形式的参数。对于这个`main`方法而言,前面的`public`和`static`修饰符的位置可以互换,但其他部分则是固定的
* 在Java程序里执行输出有两种简单的方式:`System.out.print(需要输出的内容)`和`System.out.println(需要输出的内容)`,其中前者在输出结束后不会换行,而后者在输出结束后会换行。
## Java的垃圾回收机制
* 与C/C++程序不同,Java语言不需要程序员直接控制内存回收,Java程序的内存分配和回收都是由JRE在后台自动进行的。JRE会负责回收那些不再使用的内存,这种机制被称为垃圾回收`(Garbage Collection,GC)`。通常JRE会提供一个后台线程来进行检测和控制,一般都是在CPU空闲或内存不足时自动进行垃圾回收,而程序员无法精确控制垃圾回收的时间和顺序等。
* 垃圾回收能自动释放内存空间,减轻编程的负担。这使Java虚拟机具有两个显著的优点。
    * 垃圾回收机制可以很好地提高编程效率。在没有垃圾回收机制时,可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程时,依靠垃圾回收机制可大大缩短时间。
    * 垃圾回收机制保护程序的完整性,垃圾回收是Java语言安全性策略的一个重要部分。
* 通常,垃圾回收具有如下几个特点。
    * 垃圾回收器的工作目标是回收无用对象的内存空间,这些内存空间都是JVM堆内存里的内存空间,垃圾回收器只能回收内存资源,对其他物理资源,如数据库连接、磁盘I/O等资源则无能为力。
    * 为了更快地让垃圾回收器回收那些不再使用的对象,可以将该对象的引用变量设置为null,通过这种方式暗示垃圾回收器可以回收该对象。
    * 垃圾回收发生的不可预知性。由于不同JVM采用了不同的垃圾回收机制和不同的垃圾回收算法,因此它有可能是定时发生的,有可能是当CPU空闲时发生的,也有可能和原始的垃圾回收一样,等到内存消耗出现极限时发生,这和垃圾回收实现机制的选择及具体的设置都有关系。虽然程序员可以通过调用`Runtime`对象的`gc()`或`System.gc()`等方法来建议系统进行垃圾回收,但这种调用仅仅是建议,依然不能精确控制垃圾回收机制的执行。
    * 垃圾回收的精确性主要包括两个方面:
        * 一是垃圾回收机制能够精确地标记活着的对象
        * 二是垃圾回收器能够精确地定位对象之间的引用关系。前者是完全回收所有废弃对象的前提,否则就可能造成内存泄漏;而后者则是实现归并和复制等算法的必要条件,通过这种引用关系,可以保证所有对象都能被可靠地回收,所有对象都能被重新分配,从而有效地减少内存碎片的产生。
    * 现在的JVM有多种不同的垃圾回收实现,每种回收机制因其算法差异可能表现各异,有的当垃圾回收开始时就停止应用程序的运行,有的当垃圾回收运行时允许应用程序的线程运行,还有的在同一时间允许垃圾回收多线程运行。

当编写Java程序时,一个基本原则是:对于不再需要的对象,不要引用它们。如果保持对这些对象的引用,垃圾回收机制暂时不会回收该对象,则会导致系统可用内存越来越少;当系统可用内存越来越少时,垃圾回收执行的频率就越来越高,从而导致系统的性能下降。